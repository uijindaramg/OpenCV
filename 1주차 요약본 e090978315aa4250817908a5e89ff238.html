<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>1주차 요약본</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-interactiveBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="e0909783-15aa-4250-8179-08a5e89ff238" class="page sans"><header><h1 class="page-title">1주차 요약본</h1><p class="page-description"></p><table class="properties"><tbody><tr class="property-row property-row-person"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesPerson"><path d="M10.9536 7.90088C12.217 7.90088 13.2559 6.79468 13.2559 5.38525C13.2559 4.01514 12.2114 2.92017 10.9536 2.92017C9.70142 2.92017 8.65137 4.02637 8.65698 5.39087C8.6626 6.79468 9.69019 7.90088 10.9536 7.90088ZM4.4231 8.03003C5.52368 8.03003 6.42212 7.05859 6.42212 5.83447C6.42212 4.63843 5.51245 3.68945 4.4231 3.68945C3.33374 3.68945 2.41846 4.64966 2.41846 5.84009C2.42407 7.05859 3.32251 8.03003 4.4231 8.03003ZM1.37964 13.168H5.49561C4.87231 12.292 5.43384 10.6074 6.78711 9.51807C6.18628 9.14746 5.37769 8.87231 4.4231 8.87231C1.95239 8.87231 0.262207 10.6917 0.262207 12.1628C0.262207 12.7974 0.548584 13.168 1.37964 13.168ZM7.50024 13.168H14.407C15.4009 13.168 15.7322 12.8423 15.7322 12.2864C15.7322 10.8489 13.8679 8.88354 10.9536 8.88354C8.04492 8.88354 6.17505 10.8489 6.17505 12.2864C6.17505 12.8423 6.50635 13.168 7.50024 13.168Z"></path></svg></span>작성자</th><td><span class="user"><img src="https://lh3.googleusercontent.com/a/AATXAJwOz6vFGH1TutXEl3G04z0-ftWiKsAZPi1lJz0=s100" class="icon user-icon"/>이의진(엘텍공과대학 휴먼기계바이오공학부) ‎</span></td></tr></tbody></table></header><div class="page-body"><h1 id="6bfe19db-141b-48ce-ae43-3486ee7a870b" class="">Chapter 02 OpenCV로 시작하는 컴퓨터 비전</h1><h2 id="5099f940-6f0a-43f8-a7f6-af8e131838e6" class="">2.1 OpenCV 소개</h2><ul id="d074b4cf-b3b0-4fad-9438-aa6cd580a1b7" class="bulleted-list"><li style="list-style-type:disc">OpenCV: 인텔 사에서 만들어 공개한 컴퓨터 비전 라이브러리. 함수와 클래스는 C,C++ 언어로 개발되었다. </li></ul><h2 id="57ade476-392b-424e-a77d-f435dab95e27" class="">2.3 객체지향 잘 활용하기</h2><ul id="eb583d9f-5151-4a00-ab1d-e08028a6570b" class="bulleted-list"><li style="list-style-type:disc">객체 확인<ul id="4b86ca86-71a6-4d55-9a60-5900ce1deb6e" class="bulleted-list"><li style="list-style-type:circle">type: 객체의 자료형 반환</li></ul><ul id="41327565-0f20-4ad7-a2e9-758a098e4ccc" class="bulleted-list"><li style="list-style-type:circle">dir: 객체의 모든 속성과 method 목록 반환</li></ul><p id="2ce1b01a-5641-4847-8f9d-52a3d4bdac2d" class="">
</p></li></ul><h2 id="5449c0ef-62fe-4ad6-8674-d6917e59a6b0" class="">2.4 영상을 읽고 표시하기</h2><p id="a310d8ff-d196-412c-8a9d-2adaa9a4e04d" class=""><mark class="highlight-yellow_background">2-2. 영상파일을 읽고 윈도우에 디스플레이한다.</mark></p><pre id="6a25f27b-c33e-43d3-a6a5-71c75049cf8a" class="code"><code>import cv2 as cv
import sys 
## sys: 시스템 변수를 설정/ exit함수로 프로그램 종료.

img=cv.imread(&#x27;soccer.jpg&#x27;)
if img is None:
    sys.exit(&#x27;파일을 찾을 수 없습니다.&#x27;)
    
## cv.imshow(윈도우의 이름, 디스플레이할 영상)
cv.imshow(&#x27;Soccer Image Display&#x27;,img) 

## 키 입력을 기다렸다가 윈도우를 닫고 프로그램 종료.
cv.waitKey()
cv.destroyAllWindows()</code></pre><p id="500fe1c4-18ef-44a7-a4e9-119f7ddd8352" class="">1) 이미지 읽기</p><pre id="3148a2bc-2f72-411b-bd5b-0f2d3655173d" class="code"><code>cv2.imread(fileName, flag)</code></pre><p id="0a2004ab-7b26-474e-95dc-a4542eb87fbf" class="">2) 이미지 보기</p><pre id="c96e3cfe-443e-4bcf-ba33-13697ee005d7" class="code"><code>cv2.imshow(윈도우의 이름, 디스플레이할 영상)</code></pre><p id="38eda541-c234-4744-a565-9beba7ddd92f" class="">3) 키 입력을 기다리다가, 키가 눌리면 해당 키의 유니코드 값을 반환</p><pre id="5dd17ec8-cd95-497b-85d1-54eceae190b1" class="code"><code>cv.waitKey()</code></pre><p id="1572383a-f7c3-46c4-9fe2-9c2b80e625cf" class="">4) 모든 윈도우 닫고 프로그램 종료</p><pre id="83e4bb99-fb3c-427f-8530-55efcb5f9fb8" class="code"><code>cv.destroyAllWindows()</code></pre><ul id="005979f6-dcab-4be2-8a23-53fad6b44162" class="bulleted-list"><li style="list-style-type:disc"><strong>OpenCV는 numpy로 영상을 표현한다. </strong></li></ul><ul id="f0959bce-6962-49b3-9027-f48ab36b3bdc" class="bulleted-list"><li style="list-style-type:disc">이미지는 행(y) X 열(x) X 채널(BGR) 3차원 배열</li></ul><ul id="9fbeeb23-8ad6-44a6-b3a8-f68ecdd15f2b" class="bulleted-list"><li style="list-style-type:disc">pixel: 영상을 구성하는 한 점 </li></ul><ul id="8bf4943b-1348-4448-9693-c023c365257e" class="bulleted-list"><li style="list-style-type:disc">pixel의 위치: (r,c)</li></ul><ul id="302ccaeb-2ba3-4582-b664-cf6e7040c575" class="bulleted-list"><li style="list-style-type:disc">CV에서는 왼쪽 위가 원점<ul id="9eadae1e-5eb0-48b6-a7d3-50efd5a18d80" class="bulleted-list"><li style="list-style-type:circle">ex) img.shape = (948,1434,3)</li></ul><figure id="d82e227c-e7d3-48ff-b5dc-0c43adfc3433" class="image"><a href="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled.png"><img style="width:288px" src="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled.png"/></a></figure><p id="3d868fea-2279-47ee-bf29-7ccc576cad7f" class="">
</p></li></ul><h2 id="1153e709-52fe-47fc-b649-ce6d041ab575" class="">2.5 영상 형태 변환하고 크기 축소하기</h2><p id="bc501d70-d35a-4bde-81de-f1ce03db3ed5" class=""><mark class="highlight-yellow_background">2-3. 영상을 명암 영상으로 변환하고 반으로 축소하기</mark></p><pre id="e6fb4b8d-a066-4876-b59e-b3e49e3bd93d" class="code"><code>gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY) # BGR 컬러 영상을 명암 영상으로 변환
gray_small=cv.resize(gray,dsize=(0,0),fx=0.5,fy=0.5)  # 반으로 축소

cv.imwrite(&#x27;soccer_gray.jpg&#x27;,gray)  # 영상을 파일에 저장
cv.imwrite(&#x27;soccer_gray_small.jpg&#x27;,gray)

cv.imshow(&#x27;Color image&#x27;,img)
cv.imshow(&#x27;Gray image&#x27;,gray)
cv.imshow(&#x27;Gray image small&#x27;,gray_small)

cv.waitKey()
cv.destroyAllWindows()</code></pre><p id="50577d61-d9bb-4e8b-80c7-578ba173ef67" class="">1) 컬러영상을 명암 영상으로 변환</p><pre id="b88379ef-28a0-4c76-a353-2dc693ff38c0" class="code"><code>cv2.cvtColor(img,cv.COLOR_BGR2GRAY)</code></pre><p id="f07ef9e7-58cd-416f-a421-008cc72cc261" class="">2) 영상 저장</p><pre id="2029e1c7-d7d9-43f7-9fb7-98ba1ac3d1b7" class="code"><code>cv2.imwrite(fileName, image)</code></pre><p id="091a64ef-832f-493c-ac8c-44138755a4c5" class="">3) 영상 크기 조절</p><pre id="a12fb5d8-dfa9-4e41-bb34-3c3a2c801924" class="code"><code>cv2.resize(입력 영상, dsize=(결과 영상), fx=가로방향 크기 변환 비율, fy=세로방향 크기 변환 비율)</code></pre><ul id="71b1cbad-fda0-4224-8dab-03742afb90a6" class="bulleted-list"><li style="list-style-type:disc">cvtColor함수가 BGR 영상을 명암 영상으로 변환하는 공식</li></ul><figure id="cf0072d9-cf96-464e-a567-62c792fa6775" class="image"><a href="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%201.png"><img style="width:391px" src="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%201.png"/></a></figure><h2 id="b19df685-cdba-441a-abea-ec9ca97acb6c" class="">2.6 웹 캠에서 비디오 읽기</h2><p id="81b6ad83-fe66-4ce8-b4b0-60c782c6751b" class=""><mark class="highlight-yellow_background">2-4. 웹 캠으로 비디오 획득하기</mark></p><pre id="012f27be-06ae-4d93-aeab-294544679106" class="code"><code>import cv2 as cv
import sys

cap = cv.VideoCapture(0,cv.CAP_DSHOW)  # 카메라와 연결 시도

if not cap.isOpened():
    sys.exit(&#x27;카메라 연결 실패&#x27;)

while True:
    ret, frame = cap.read()# 비디오를 구성하는 프레임 획득

    if not ret:
        print(&#x27;프레임 획득에 실패하여 루프를 나납니다.&#x27;)
        break

    cv.imshow(&#x27;Video display&#x27;, frame)

    key = cv.waitKey(1) # 1밀리초 동안 키보드 입력 기다림
    if key==ord(&#x27;q&#x27;):#&#x27;q&#x27;입력 시 루프 탈출
        break

cap.release() # 카메라와 연결을 끊음
cv.destroyAllWindows() # 윈도우를 모두 닫음</code></pre><p id="aa6fea49-3e96-4c46-be41-c1088e68b662" class="">1) 웹 캠과 연결 시도→ 연결 실패 시 cap.isOpened()가 False</p><pre id="56b109c4-a6f0-4fde-9cc5-54d7e7af4e23" class="code"><code>cap = cv.VideoCapture(0,cv.CAP_DSHOW)
# 카메라와 연결 시도하는 결과를 cap에 저장</code></pre><p id="e26dd7c1-31ab-45d2-9fdd-807396cdb614" class="">2) 동영상 입력 무한 반복</p><pre id="a1121176-37c9-4cff-83a3-b8b386a88cae" class="code"><code>ret, frame = cap.read()</code></pre><ul id="6ee7e1f7-1a13-4256-b89f-ce56b2009a73" class="bulleted-list"><li style="list-style-type:disc">read함수: 호출한 순간의 프레임을 획득하고 성공 여부, 프레임 반환</li></ul><ul id="4bdaadea-322c-4097-8c65-47f6d7001d22" class="bulleted-list"><li style="list-style-type:disc">ret객체(성공 여부), frame객체(호출한 순간의 영상 한 장, 프레임) 저장</li></ul><p id="abbf683b-3691-4932-a72d-643923bd1042" class="">3) 영상 디스플레이</p><p id="43045110-0392-41f9-b61d-dea5480d2176" class="">
</p><p id="e5780b8e-9a85-4dd7-8764-dd99f5223cde" class=""><mark class="highlight-yellow_background">2.5 비디오에서 수집한 영상을 이어 붙이기</mark></p><pre id="d06f4079-1e36-407c-a286-0036036e649d" class="code"><code>import cv2 as cv
import numpy as np
import sys

cap=cv.VideoCapture(0,cv.CAP_DSHOW) #카메라와 연결 시도

if not cap.isOpened():
	sys.exit(&#x27;카메라 연결 실패)

frames=[]
while True:
	ret,frame cap.read() #비디오를 구성하는 프레임 획득

	if not ret:
		print(&#x27;프레임 획득에 실패하여 루프를 나갑니다.)
		break

	cv.imshow(&quot;Video display&#x27;, frame)

	key=cv.waitKey(1)#1밀리초 동안 키보드 입력 기다림
	if key==ord(&#x27;c&#x27;):# &#x27;C&#x27; 키가 들어오면 프레임을 리스트에 추가
		frames.append(frame)#&#x27;q&#x27;키가 들어오면 루프를 빠져나감
	elif key==ord(&#x27;q&#x27;):
		break

cap.release()#카메라와 연결을 끊음
cv.destroyAllWindows()

if len(frames)&gt;0:#수집된 영상이 있으면
	imgs=frames[0]
	for i in range(1,min(3, len(frames))): #최대 3개까지 이어 붙임.
		imgs=np.hstack((imgs, frames[i]))

	cv.imshow(&quot;collected images&#x27;,imgs)
	
	cv.waitKey()
	cv.destroyAllWindows()

</code></pre><ul id="ce42face-816f-4d74-96b4-04c669312ca9" class="bulleted-list"><li style="list-style-type:disc">np.hstack: 넘파이 배열을 가로로 결합
</li></ul><figure id="a3011005-bbf5-4268-8f45-8fddbcbeaa6f" class="image"><a href="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%202.png"><img style="width:758px" src="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%202.png"/></a></figure><h2 id="a2cdd707-448d-4836-be2d-1a81cfd2e301" class="">2.7 그래픽 기능과 사용자 인터페이스 만들기</h2><p id="af8d788b-dc4d-4356-96d4-e6dc86100c4b" class="">1) 영상에 도형 그리기</p><pre id="5755f39a-0b2a-46dd-ab67-615d5b6e3c41" class="code"><code>cv2.rectangle(img, (직사각형의 왼쪽 위 구석점의 x좌표, y좌표), (직사각형의 오른쪽 아래 구석점의 x좌표, y좌표), (B,G,R), 선의 두께)</code></pre><p id="1886410a-2378-49ea-9a62-09201c261575" class="">2) 영상에 글씨 쓰기</p><pre id="c5e2c60e-3f65-46bb-8587-91842db01e28" class="code"><code>cv2.putText(image, &#x27;text&#x27;, 문자열의 왼쪽 아래 구석점의 위치, font, fontScale, color, thickness)
</code></pre><p id="1a04de8a-c329-40c5-8f4f-200649e22073" class=""><mark class="highlight-yellow_background">2.7 마우스 클릭한 곳에 직사각형 그리기</mark></p><pre id="2d747cf1-6b99-467a-9f50-90d552681139" class="code"><code>def draw(event,x,y, flags, param):#콜백 함수
	if event==cv.EVENT_LBUTTONDOWN:# 왼쪽 버튼 클릭
		cv.rectangle(img, (x,y), (x+200, y+200), (0,0,255), 2)
	elif event==cv.EVENT_RBUTTONDOWN: #오른쪽 버튼 클릭
		cv.rectangle(img, (x,y), (x+100, y+100), (255,0,0),2)

	cv.imshow(&#x27;Drawing&#x27;,img)
		
cv.namedWindow(&#x27;Drawing&#x27;) 
cv.imshow(&#x27;Drawing&#x27;,img)

cv.setMouseCallback(&#x27;Drawing&#x27;,draw) #Drawing 윈도우에 draw 콜백 함수 지정
# 마우스 이벤트 발생 -&gt; draw 호출

while(True): #마우스 이벤트가 언제 발생할지 모름-&gt; 무한 루프를 돌며 프로그램 실행 지속
	if cv.waitKey(1)==ord(&#x27;q&#x27;): 
		cv.destroyAllWindows()
		break</code></pre><ul id="90e38a1b-5d7d-47bd-ba5e-1fc7efd8fd45" class="bulleted-list"><li style="list-style-type:disc">callback function: 다른 함수의 인자로써 이용되는 함수</li></ul><h1 id="16dc831e-8eb0-44c4-9e3a-39b5cb6217da" class="">Chapter 03 영상 처리</h1><h2 id="30aa492b-6006-438d-bfff-3a454f268f15" class="">3.1 디지털 영상 기초</h2><p id="ed98a4b8-32ef-4fa4-b992-27bca7ba187e" class=""><mark class="highlight-orange_background">아날로그 신호→디지털 변환                                                                                                                   </mark></p><ul id="1bf67a02-34e8-401b-b7e5-18974d46e500" class="bulleted-list"><li style="list-style-type:disc">어떠한 과정을 통해 아날로그 신호를 받았다→ <mark class="highlight-red">샘플링(sampling)</mark>과 <mark class="highlight-red">양자화(quantization)</mark>를 통해 디지털 영상으로 변환</li></ul><ul id="d4951a49-79b9-4bbd-a678-b8c056e7f306" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red">샘플링</mark>: 2차원 영상 공간을 가로 방향 N X 세로 방향 M개 구간으로 나눔<ul id="2096ca2e-0c59-4a0e-b9dd-52689f80677f" class="bulleted-list"><li style="list-style-type:circle">화소(pixel): 샘플링을 통해 형성된 한 점</li></ul><ul id="0e089038-5975-42a8-91c8-f044f45882b9" class="bulleted-list"><li style="list-style-type:circle"><strong>M</strong> X <strong>N</strong>: 영상 크기(size), 해상도(resolution)</li></ul></li></ul><ul id="1cb4ec61-8ee7-47d8-a84f-b060978b87ec" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red">양자화</mark>: 화소의 명암을 L개 구간으로 나눔.</li></ul><figure id="1d7bd91f-ff7d-4020-9b4c-a088228703c6" class="image"><a href="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%203.png"><img style="width:432px" src="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%203.png"/></a></figure><p id="a455d7e1-1d10-41a0-a618-f3c9196647c7" class="">
</p><p id="da404e7e-70d0-4448-a605-00d657aee0d2" class=""><mark class="highlight-orange_background">디지털 영상 좌표계의 특징                                                                                                   </mark></p><figure id="019770a6-3e22-4c06-8df3-2e2f6bb165d8" class="image" style="text-align:left"><a href="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%204.png"><img style="width:240px" src="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%204.png"/></a></figure><ul id="7a7e0eea-8df4-40cb-a2fd-e7bb68e2352f" class="bulleted-list"><li style="list-style-type:disc">원점이 왼쪽 위이다</li></ul><ul id="018a2f77-1623-47b8-8ee8-e656d47dc89f" class="bulleted-list"><li style="list-style-type:disc"> (x,y)대신 (y,x)표기를 사용<ul id="1ba421e3-e591-4a0c-986a-7c8416ae9463" class="bulleted-list"><li style="list-style-type:circle">화소의 위치를 지정할 때→ (y,x)표기</li></ul><ul id="df005da0-4471-4163-bf42-8abd962d21c8" class="bulleted-list"><li style="list-style-type:circle">그 외의 경우→(x,y)</li></ul></li></ul><p id="7bed0bc7-6746-4962-b2ac-2f2386c962e5" class=""><mark class="highlight-orange_background">다양한 종류의 영상                                                                                                                      </mark></p><figure id="cd7a4126-9461-45a1-aee6-3002b6bc3b40" class="image"><a href="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%205.png"><img style="width:480px" src="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%205.png"/></a></figure><p id="80589d2b-697f-485f-b390-0ddd148db97a" class="">(a) 명암 영상(grayscale image): 2차원 구조의 배열. 채널 하나</p><p id="d8fdef23-f03a-40b9-b737-99b27192b6d0" class="">(b) 컬러 영상: 3차원 배열. 3개 채널(R,G,B)로 구성</p><p id="82e2b08f-3f71-45fb-9b37-ce67508bdbd5" class="">(c) 컬러 동영상: 4차원 구조의 배열. </p><p id="479110d7-52c4-4c47-b14a-e1330fd2e476" class="">(d) 다분광, 초분광, 의료영상 : 3차원 구조의 배열. 세 번째 축의 크기가 확장됨<div class="indented"><p id="dcd47b93-7bf4-4b8c-8815-8336cd30341c" class="">ex)MRI-xy평면이 신체의 한 단면. z축은 신체의 위에서 아래로 진행</p></div></p><p id="dfe023ff-e46c-4265-8f82-e447777fca32" class="">(e) RGB-D 영상: 물체까지의 거리를 측정한 영상. RGB컬러 센서 + 깊이 센서로 획득. </p><p id="4ff27916-37e1-48c1-b2db-4458d0ccb8b0" class="">
</p><p id="f3638c6a-9cfe-41f2-930c-4f9e921a9e55" class=""><mark class="highlight-orange_background">RGB 채널별로 디스플레이                                                                                                                   </mark></p><figure id="65efafc7-0a98-4cb3-9c1c-502d69d4a16b" class="image"><a href="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%206.png"><img style="width:732px" src="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%206.png"/></a></figure><p id="f4e220b6-5880-479a-9fce-3d65e763ec3a" class="">img.shape=(948,1434,3)를 슬라이싱하고 채널별로 분리해 디스플레이.</p><pre id="d4d26f02-0b84-434e-bfbc-e8eb70a1eaaa" class="code"><code>import cv2 as cv import sys
img=cv.imread(&#x27;soccer.jpg&#x27;)
if img is None:
sys.exit(&#x27;파일을 찾을 수 없습니다.&#x27;)

cv.imshow(&#x27;original_RGB&#x27;, img)
cv.imshow(&#x27;Upper left half&#x27;, img[0:img.shape[0]//2,0:img.shape[1]//2,:])
cv.imshow(&#x27;Center half&#x27;,img[img.shape[0]//4:3*img.shape[0]//4, img.shape[1]//4:3*img.shape[1]//4,:])

cv.imshow(&#x27;R channel&#x27;,img[:,:,2])
cv.imshow(&#x27;G channel&#x27;,img[:,:,1])
cv.imshow(&#x27;B channel&#x27;,img[:,:,0])

cv.waitKey()
cv.destroyAllWindows()</code></pre><p id="0c077cb8-794e-4193-ab55-498c98349143" class="">
</p><h2 id="a34ece36-5b57-49cc-8c3d-9b3eda3a1ee7" class="">3.2 이진 영상</h2><ul id="16732cb7-0c1b-427e-afa0-2aa67339ec61" class="bulleted-list"><li style="list-style-type:disc">이진영상(binary image): 화소가 0(흑) 또는 1(백)</li></ul><ul id="b01b9164-d447-42ee-b0ec-14e072aa23a5" class="bulleted-list"><li style="list-style-type:disc">CV에서의 활용: 에지만 1로 표현하기, 물체 검출한 후 물체_1 배경_0으로 표시하기</li></ul><p id="e0397bd0-0da7-4242-9b5a-0bae70bf7a93" class=""><mark class="highlight-orange_background"><strong>이진화</strong></mark></p><ul id="b18f4746-5ef6-400f-bd9a-49b5eda3e083" class="bulleted-list"><li style="list-style-type:disc">binary image: 임곗값(threshold) T 보다 크면 1, 아니면 0. T의 결정이 중요함.</li></ul><figure id="6b2e23e6-b2bd-43c9-a5e7-783227bfd1c9" class="image"><a href="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%207.png"><img style="width:240px" src="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%207.png"/></a></figure><ul id="6f3937f2-12ca-4b65-af78-fbdc43acd815" class="bulleted-list"><li style="list-style-type:disc">히스토그램의 계곡을 T로 결정하는게 Best! </li></ul><ul id="a90a146a-895a-4f46-84ac-624ac949873d" class="bulleted-list"><li style="list-style-type:disc">계곡이 불분명하거나 많을 경우에는 T 결정이 어렵다. </li></ul><p id="ec1b5cf7-b51d-43b9-a911-df16995518af" class="">→ 이를 해결하고자하는게 오츄 알고리즘임.</p><p id="d1d5486b-3457-4563-a7cc-696b9ef42b56" class=""><mark class="highlight-orange_background"><strong>오츄 알고리즘 </strong></mark></p><ul id="0fd51e16-4656-4126-b43c-42be61a21e7c" class="bulleted-list"><li style="list-style-type:disc">이진화는 최적화 문제로 공식화하여 푼다.<figure id="d1dfa450-a019-4359-a846-d5531bbff4b6" class="image"><a href="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%208.png"><img style="width:284px" src="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%208.png"/></a></figure><p id="40204c0d-ca99-4426-a05c-23344c78ffce" class="">t: 명암값(pixel value) </p><p id="736267b6-ab9f-4d45-97bc-1ee144251e54" class="">J: 목적 함수</p></li></ul><ul id="9ad57e00-9fa6-4c34-a4ee-6056ce229952" class="bulleted-list"><li style="list-style-type:disc">목적 함수 J(t): 0이 되는 pixel value의 분산과 1이 되는 pixel value의 부산의 weighted sum.</li></ul><figure id="ce65d623-8d77-4338-a04e-785952e4cdf1" class="image" style="text-align:left"><a href="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%209.png"><img style="width:288px" src="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%209.png"/></a></figure><ul id="6de88c29-d112-4b45-8273-d9dd0b387a54" class="bulleted-list"><li style="list-style-type:disc">exhaustive search algorithms: 모든 해(t)를 다 검사하여 최소가 되는 t를 결정한다.→현실성이 없어 역전파 알고리즘 등을 사용함.</li></ul><p id="c5ee1dbf-5707-4195-950c-afabfd73df8f" class="">
</p><p id="7b705b2d-67b6-4989-be3f-0769dbfc1d61" class=""><mark class="highlight-orange_background"><strong>연결요소 </strong></mark></p><ul id="7a68da73-6889-4fd5-90b2-4fb8902e70eb" class="bulleted-list"><li style="list-style-type:disc">화소의 연결성</li></ul><figure id="0c6d1c69-2611-4a59-8f86-4ce52f846db0" class="image"><a href="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%2010.png"><img style="width:336px" src="1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%AD%E1%84%8B%E1%85%A3%E1%86%A8%E1%84%87%E1%85%A9%E1%86%AB%20e090978315aa4250817908a5e89ff238/Untitled%2010.png"/></a></figure><ul id="bdb5f7aa-b7ce-49de-9ad6-e7023e75a521" class="bulleted-list"><li style="list-style-type:disc">binary image에서 1의 값을 가진 연결된 pixel value의 집합</li></ul></div></article></body></html>